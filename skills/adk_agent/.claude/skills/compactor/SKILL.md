---
name: "智能上下文压缩器"
description: "采用 Rolling Summary 策略压缩对话历史，在清空历史前保留关键信息（任务目标、阶段性结论、任务进展）。"
---

# Execution Instructions

## 核心策略：Rolling Summary（滚动摘要）

**与传统 compactor 的区别**：
- ❌ 传统方式：直接清空所有历史 → 信息全部丢失
- ✅ Rolling Summary：先总结关键信息 → 清空历史 → 摘要作为新起点

## 执行步骤

### 原子化压缩操作（Atomic Compression）

现在，压缩操作必须在一个步骤中完成，不再分步进行。

**执行逻辑**：
1. **Thought (思考)**: 回顾当前对话，在内心生成一份结构化的摘要（包含任务目标、进展、关键数据等）。
2. **Action (行动)**: 直接调用 `smart_compact(summary="...")`，将生成的摘要作为参数传入。

**摘要模板（供参考）**：
```text
## 任务目标
[用户原始请求]

## 进展
- [已完成步骤]

## 关键数据
- [文件路径/配置值]

## 待办
- [下一步计划]
```

### 注入摘要

`smart_compact` 执行成功后，会返回包含摘要的确认信息。请将此信息作为新对话的起点。

## 可用工具

### smart_compact
智能压缩：接收摘要，清空历史，卸载工具。
**参数**: `summary` (必填) - 当前对话的完整摘要。

### get_compression_status
获取当前状态和压缩建议。

## 主动调用时机

Agent 应在以下情况**主动**调用 compactor：

| 触发条件          | 说明                       |
| ----------------- | -------------------------- |
| 对话轮次 > 15 轮  | 上下文过长，影响性能       |
| 已加载工具 > 8 个 | 工具列表膨胀               |
| 任务阶段切换      | 完成一个大任务，开始新任务 |
| 用户明确要求      | "清理历史" / "重置状态"    |

## 示例流程

```
用户: "继续之前的代码分析任务"

Agent 思考: "对话已经很长了，我应该压缩一下"

Step 1 - 生成摘要:
"## 任务目标
分析项目中的内存泄漏问题

## 已完成
- 使用 codebase_search 定位了 3 个可疑文件
- 使用 bash 检查了进程内存

## 关键发现
- memory_pool.py 第 45 行存在未释放的资源
- 问题出现在 process_data() 函数中

## 待处理
- 需要修复 memory_pool.py 的问题"

Step 2 - 执行压缩:
Action: smart_compact()
Result: [OK] 已清空历史，已卸载 5 个工具

Step 3 - 继续任务:
"根据之前的分析，memory_pool.py 第 45 行存在问题，
现在让我加载 codebase_search 继续处理..."
```

## 重要提醒

1. **压缩前必须生成摘要** - 否则关键信息会丢失
2. **摘要要简洁但完整** - 保留任务目标、结论、进展
3. **压缩后主动告知用户** - 让用户知道之前做了什么
