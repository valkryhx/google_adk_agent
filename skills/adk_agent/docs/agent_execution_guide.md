# ADK Dynamic Skills Agent 执行原理详解

> 本文档详细说明 Agent 的执行流程、技能加载机制和提示词设计，适合开发人员和 LLM Agent 学习参考。

---

## 一、执行流程概览

以用户输入 **"检查我的系统内存使用情况"** 为例，展示完整执行过程：

### 整体流程图

```
用户输入
    ↓
┌─────────────────────────────────────────────────────────────┐
│ Phase 1: 初始化（只执行一次）                                 │
│ ┌─────────────────────────────────────────────────────────┐ │
│ │ 1. SkillManager 扫描 .claude/skills/ 目录               │ │
│ │ 2. 提取所有技能的 name + description (不加载完整Instructions)      │ │
│ │ 3. 生成技能清单注入到 Agent 的 system prompt            │ │
│ │ 4. Agent 启动时只有 skill_load 一个工具                  │ │
│ └─────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
    ↓
┌─────────────────────────────────────────────────────────────┐
│ Phase 2: 用户请求处理                                        │
│                                                             │
│ 用户: "检查我的系统内存使用情况"                              │
│                                                             │
│ ┌─────────────────────────────────────────────────────────┐ │
│ │ LLM 思考:                                               │ │
│ │ "用户要检查内存，我查看可用技能清单：                      │ │
│ │  - codebase_search: 代码搜索 ❌                         │ │
│ │  - data_analyst: 数据分析 ❌                            │ │
│ │  - bash: 系统命令执行 ✅ 最匹配！              │ │
│ │  - compactor: 上下文压缩 ❌                             │ │
│ │ 我需要加载 bash 技能"                         │ │
│ └─────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
    ↓
┌─────────────────────────────────────────────────────────────┐
│ Phase 3: 技能加载                                            │
│                                                             │
│ LLM 调用: skill_load("bash")                       │
│                                                             │
│ ┌─────────────────────────────────────────────────────────┐ │
│ │ skill_load 函数执行:                                      │ │
│ │ 1. 动态加载 bash/tools.py                     │ │
│ │ 2. 挂载 7 个工具到 Agent.tools:                         │ │
│ │    - bash                                  │ │
│ │    - get_system_info                                    │ │
│ │    - list_processes                                     │ │
│ │    - get_network_info                                   │ │
│ │    - ping_host                                          │ │
│ │    - check_port                                         │ │
│ │    - get_environment_variables                          │ │
│ │ 3. 读取并返回 SKILL.md 的完整 Instructions                        │ │
│ └─────────────────────────────────────────────────────────┘ │
│                                                             │
│ 返回给 LLM:                                                  │
│ "[OK] 技能 'bash' 已加载，以下是执行指令：          │
│  ...完整的 SKILL.md 内容..."                                 │
└─────────────────────────────────────────────────────────────┘
    ↓
┌─────────────────────────────────────────────────────────────┐
│ Phase 4: 按 Instructions 执行任务                                     │
│                                                             │
│ ┌─────────────────────────────────────────────────────────┐ │
│ │ LLM 思考 (阅读 Instructions 后):                                  │ │
│ │ "根据 Instructions，检查内存有两种方式：                           │ │
│ │  1. get_system_info() - 直接获取系统信息                 │ │
│ │  2. bash('systeminfo') - Windows 命令       │ │
│ │ get_system_info() 更直接，我选择这个"                    │ │
│ └─────────────────────────────────────────────────────────┘ │
│                                                             │
│ LLM 调用: get_system_info()                                 │
│                                                             │
│ 返回:                                                        │
│ "[操作系统]                                                  │
│    系统: Windows 10                                          │
│  [内存]                                                      │
│    总量: 32.00 GB                                            │
│    已用: 12.50 GB (39.1%)                                    │
│    可用: 19.50 GB"                                           │
└─────────────────────────────────────────────────────────────┘
    ↓
┌─────────────────────────────────────────────────────────────┐
│ Phase 5: 生成最终回答                                        │
│                                                             │
│ LLM 输出:                                                    │
│ "您的系统内存使用情况如下：                                   │
│  - 总内存：32 GB                                             │
│  - 已使用：12.5 GB (39.1%)                                   │
│  - 可用：19.5 GB                                             │
│  内存使用率在正常范围内。"                                    │
└─────────────────────────────────────────────────────────────┘
```

---

## 二、两阶段懒加载机制

### 核心设计思想

为了节省 Token 和提高效率，技能采用**两阶段懒加载**：

```python
# 阶段1：发现（Agent 初始化时执行）
# 只读取 YAML 头部的 name + description
manifests = sm.get_discovery_manifests()
# 返回: 
# - id: bash
#   name: 系统命令执行专家
#   description: 执行系统 Shell 命令，用于系统诊断...

# 阶段2：加载（用户请求时按需执行）
# 读取完整的 SKILL.md 内容，包含详细 Instructions
sop = sm.load_full_sop("bash")
# 返回完整的执行步骤、示例、工具说明
```

### 为什么这样设计？

| 设计选择                  | 好处                          |
| ------------------------- | ----------------------------- |
| 初始只加载摘要            | 减少首次 Token 消耗，加快启动 |
| 按需加载完整 Instructions | 只在需要时才消耗 Token        |
| 动态挂载工具              | 工具列表精简，LLM 决策更准确  |

---

## 三、初始提示词 (System Prompt)

LLM 是根据初始提示词中的**技能清单**和**规则**来决定加载哪个技能的。

### 完整提示词模板

```markdown
你是一个高级智能助手，具备动态加载专业技能的能力。

## 核心身份
- 名称: Dynamic_Expert
- 角色: 按需加载技能的智能体
- 特点: 精确、高效、善于多轮推理

## 可用技能清单                    ← 动态注入
- id: codebase_search
  name: 代码库搜索专家
  description: 通过 ripgrep 精确定位代码

- id: bash              ← LLM 匹配到这个
  name: 系统命令执行专家
  description: 执行系统命令，用于系统诊断...

- id: data_analyst
  name: 数据分析专家
  description: CSV 数据分析和图表生成

- id: compactor
  name: 上下文压缩器
  description: 清空历史并卸载工具

## 工作原则

### 1. 技能加载策略               ← 关键规则
- 在执行任务前，先分析需要哪个技能
- 使用 `skill_load(skill_id)` 加载技能
- 严格按照 Instructions 指令执行
- 技能是叠加的：可以连续加载多个技能

### 2. 技能链 (Skill Chain)
对于复杂任务，可以组合多个技能形成处理链：
- 分析任务：将问题分解为子任务
- 规划链条：确定每个子任务需要哪个技能
- 顺序执行：按顺序加载并使用各技能
- 结果整合：将各步骤结果合并

示例：
任务: "找到项目中最大的 Python 文件，并分析其内存使用"
链条: codebase_search → bash → data_analyst

### 3. 多轮推理策略 (ReAct)
Thought: 分析当前状态
Action: 调用工具
Observation: 观察结果
... (重复)
Answer: 最终答案
```

### LLM 的决策过程

```
用户输入: "检查我的系统内存"

LLM 思考 (基于提示词中的规则): 
"根据提示词第 1 条规则，我需要先分析需要哪个技能。
 查看技能清单：
 - bash 的 description 包含'系统诊断'
 - 这与用户的'系统内存'需求匹配
 - 所以我应该调用 skill_load('bash')"

LLM 输出: 调用 skill_load("bash")
```

---

## 四、动态工具挂载

### 工具状态变化

```python
# 加载前
my_agent.tools = [skill_load]  # 只有 1 个工具

# 执行 skill_load("bash") 后
my_agent.tools = [
    skill_load,            # 保留网关
    bash,    # 新增
    get_system_info,      # 新增
    list_processes,       # 新增
    get_network_info,     # 新增
    ping_host,            # 新增
    check_port,           # 新增
    get_environment_variables  # 新增
]  # 现在有 8 个工具

# 如果再加载 codebase_search，工具会继续叠加
# skill_load("codebase_search") 后
my_agent.tools = [
    skill_load,
    bash, get_system_info, ...  # bash 工具
    execute_ripgrep, read_file_content, ...  # codebase_search 工具
]  # 工具继续增加
```

---

## 五、技能链 (Skill Chain)

### 什么是技能链？

对于复杂任务，Agent 可以**组合多个技能**形成处理链：

```
用户: "找到项目中所有 Python 文件，统计哪个文件代码行数最多"

┌─────────────────────────────────────────────────────────────┐
│ Step 1: 加载代码搜索技能                                     │
│ Action: skill_load("codebase_search")                        │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ Step 2: 列出所有 Python 文件                                 │
│ Action: list_files(path=".", pattern="*.py")                │
│ Observation: [main.py, config.py, tools.py, ...]            │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ Step 3: 加载 Shell 执行技能（技能叠加）                       │
│ Action: skill_load("bash")                         │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ Step 4: 统计每个文件的行数                                   │
│ Action: bash("wc -l *.py")                     │
│ Observation: [行数统计结果]                                  │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ Step 5: 给出最终答案                                        │
│ "main.py 有 350 行代码，是项目中最长的文件"                  │
└─────────────────────────────────────────────────────────────┘
```

### 常见技能链示例

| 任务类型            | 技能链                                  |
| ------------------- | --------------------------------------- |
| 代码分析 + 系统诊断 | `codebase_search → bash`                |
| 数据处理 + 代码搜索 | `data_analyst → codebase_search`        |
| 系统诊断 + 结果分析 | `bash → data_analyst`                   |
| 全面项目分析        | `codebase_search → bash → data_analyst` |

---

## 六、代码调用栈

```
main.py::run_agent("检查我的系统内存使用情况")
  │
  ├─→ Runner.run_async()
  │     │
  │     ├─→ LLM 推理: 选择调用 skill_load
  │     │
  │     └─→ main.py::skill_load("bash")
  │           │
  │           ├─→ _load_skill_tools("bash")
  │           │     ├─→ importlib 加载 tools.py
  │           │     └─→ 挂载工具到 agent.tools
  │           │
  │           └─→ sm.load_full_sop("bash")
  │                 └─→ 返回 SKILL.md 内容
  │
  ├─→ LLM 推理: 根据 Instructions 选择 get_system_info
  │
  └─→ bash/tools.py::get_system_info()
        │
        ├─→ platform.system(), platform.release()
        ├─→ psutil.virtual_memory()
        ├─→ psutil.cpu_percent()
        └─→ psutil.disk_partitions()
```

---

## 七、关键文件说明

| 文件                            | 作用                                    |
| ------------------------------- | --------------------------------------- |
| `config.py`                     | 配置类 + 系统提示词模板                 |
| `main.py::skill_load()`         | 技能加载网关，动态挂载工具              |
| `core/manager.py::SkillManager` | 技能发现和 Instructions 加载            |
| `.claude/skills/*/SKILL.md`     | 技能定义（YAML头部 + Instructions正文） |
| `.claude/skills/*/tools.py`     | 技能工具实现                            |

---

## 八、核心设计原则

1. **懒加载** - 初始只加载摘要，按需加载完整 Instructions
2. **动态工具** - 运行时挂载，避免工具列表膨胀
3. **Instructions 驱动** - LLM 按照明确的执行步骤操作
4. **技能叠加** - 多次加载技能，工具累加不覆盖
5. **提示词引导** - 通过 System Prompt 教会 LLM 如何使用技能

---

> **文档版本**: 1.0  
> **最后更新**: 2025-12-29
